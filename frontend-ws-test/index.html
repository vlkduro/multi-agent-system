<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI30 WebSocket</title>
    <script src="./utils/pixi.min.js"></script>
    <link rel="stylesheet" href="css/main_style.css">
</head>
<body>
    <h1>AI30 WebSocket Debug App</h1>
    <div style="display:flex; gap:10px">
        <button id="start-simulation">Start simulation</button>
        <button id="stop-simulation">Stop simulation</button>
        <button id="new-simulation">New simulation</button>
    </div>
    <h2 id="connection-state">Connection closed</h2>
    <div>
        <canvas id="map"></canvas>
    </div>
    <div id="agents"></div>
    <div id="errors"></div>
    <script>
        const URL = 'http://localhost:8080/';
        const ws = new WebSocket('ws://localhost:8080/');
        const agentsDiv = document.getElementById('agents');
        const connectionState = document.getElementById('connection-state');
        const errorsDiv = document.getElementById('errors');

        let selectedAgt = undefined;

        document.getElementById('start-simulation').onclick = () => {
            fetch(URL + "start")
                .then(response => response.json())
                .then(data => {
                    console.log('Simulation started:', data);
                    window.location.reload();
                })
                .catch(error => {
                    console.error('Error starting simulation:', error);
                });
        }

        document.getElementById('stop-simulation').onclick = () => {
            fetch(URL + "stop")
                .then(response => response.json())
                .then(data => {
                    console.log('Simulation stopped:', data);
                    window.location.reload();
                })
                .catch(error => {
                    console.error('Error stopping simulation:', error);
                });
        }

        document.getElementById('new-simulation').onclick = () => {
            fetch(URL + "new")
                .then(response => response.json())
                .then(data => {
                    console.log('Simulation created:', data);
                    window.location.reload();
                })
                .catch(error => {
                    console.error('Error creating simulation:', error);
                });
        }


        function clearCanvas(canvas) {
            const context = canvas.getContext('2d');
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = 'lightgrey';
            context.fillRect(0, 0, canvas.width, canvas.height);
        }

        function findRightFont(ctx, startSize, text, maxHeight, maxWidth) {
            let font = startSize;
            let dimensions = ctx.measureText(text);
            while (dimensions.height > maxHeight || dimensions.width > maxWidth) {
                font--;
                ctx.font = font + 'px Arial';
                dimensions = ctx.measureText(text);
            }
            return font;
        }

        // https://stackoverflow.com/questions/808826/draw-arrow-on-canvas-tag
        function canvas_arrow(ctx, fromx, fromy, tox, toy) {
            ctx.beginPath();
            var headlen = 10; // length of head in pixels
            var dx = tox - fromx;
            var dy = toy - fromy;
            var angle = Math.atan2(dy, dx);
            ctx.moveTo(fromx, fromy);
            ctx.lineTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        function getTriangleCoordinates(startPt, height, oppositeBaseSize, orientation) {
            const topCorner = { ...startPt };
            let leftCorner, rightCorner;
            switch (orientation) {
                case 'N':
                    rightCorner = { x: startPt.x - oppositeBaseSize / 2, y: startPt.y - height };
                    leftCorner = { x: startPt.x + oppositeBaseSize / 2, y: startPt.y - height };
                    break;
                case 'S':
                    leftCorner = { x: startPt.x - oppositeBaseSize / 2, y: startPt.y + height };
                    rightCorner = { x: startPt.x + oppositeBaseSize / 2, y: startPt.y + height };
                    break;
                case 'E':
                    rightCorner = { x: startPt.x + height, y: startPt.y - oppositeBaseSize / 2 };
                    leftCorner = { x: startPt.x + height, y: startPt.y + oppositeBaseSize / 2 };
                    break;
                case 'W':
                    leftCorner = { x: startPt.x - height, y: startPt.y - oppositeBaseSize / 2 };
                    rightCorner = { x: startPt.x - height, y: startPt.y + oppositeBaseSize / 2 };
                    break;
            }
            return { topCorner, leftCorner, rightCorner };
        }

        function pointIsInTriangle(x, y, topCorner, leftCorner, rightCorner) {
            function calculateArea(x1, y1, x2, y2, x3, y3) {
                return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0);
            }

            const area = calculateArea(topCorner.x, topCorner.y, leftCorner.x, leftCorner.y, rightCorner.x, rightCorner.y);
            const area1 = calculateArea(x, y, leftCorner.x, leftCorner.y, rightCorner.x, rightCorner.y);
            const area2 = calculateArea(topCorner.x, topCorner.y, x, y, rightCorner.x, rightCorner.y);
            const area3 = calculateArea(topCorner.x, topCorner.y, leftCorner.x, leftCorner.y, x, y);

            return area === area1 + area2 + area3;
        }

        function drawAgentVision(ctx, agent, cellSize) {
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = 'rgba(0, 255, 0, 1)';
            ctx.strokeStyle = 'rgba(0, 255, 0, 1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            agent.seenElems.forEach(seen => {
                ctx.fillRect(seen.position.x * cellSize, seen.position.y * cellSize, cellSize, cellSize)
            })
            ctx.globalAlpha = 1;
            ctx.closePath();
		}

        function drawAgent(ctx, agent, cellSize) {
            text = agent.id.replace('ExAgent ', 'ExA');
            let agtX = agent.position.x * cellSize;
            let agtY = agent.position.y * cellSize;
            if (agent.id === selectedAgt) {
                ctx.fillStyle = 'lightgreen';
                drawAgentVision(ctx, agent, cellSize);
            }
            else {
                ctx.fillStyle = 'yellow';
            }
            // drawing yellow square
            ctx.fillRect(agtX, agtY, cellSize, cellSize);
            // drawing movement
            ctx.strokeStyle = 'red';
            if (agent.movement === "N") {
                canvas_arrow(ctx, agtX + cellSize / 2, agtY + cellSize, agtX + cellSize / 2, agtY);
            } else if (agent.movement === "E") {
                canvas_arrow(ctx, agtX, agtY + cellSize / 2, agtX + cellSize, agtY + cellSize/2);
            } else if (agent.movement === "S") {
                canvas_arrow(ctx, agtX + cellSize / 2, agtY, agtX + cellSize / 2, agtY + cellSize);
            } else if (agent.movement === "W") {
                canvas_arrow(ctx, agtX + cellSize, agtY + cellSize / 2, agtX, agtY + cellSize/2);
            }
            // drawing text
            font = findRightFont(ctx, 10, text, cellSize, cellSize);
            ctx.fillStyle = 'black';
            ctx.font = font + 'px Arial';
            ctx.fillText(text, agtX, agtY + cellSize / 2);
        }

        function drawObject(ctx, object, cellSize) {
            let text = object.id;
            if (object.id.includes('Flower')) {
                ctx.fillStyle = 'red';
                text = object.id.replace('Flower ', 'F');
            } 
            else if (object.id.includes('Hive')) {
                ctx.fillStyle = 'orange';
                text = object.id.replace('Hive ', 'H');
            }
            else {
                ctx.fillStyle = 'green';
            }
            objX = object.position.x * cellSize;
            objY = object.position.y * cellSize;
            ctx.fillRect(objX, objY, cellSize, cellSize);
            font = findRightFont(ctx, 10, text, cellSize, cellSize);
            ctx.fillStyle = 'black';
            ctx.font = font + 'px Arial';
            ctx.fillText(text, objX, objY + cellSize / 2);
        }

        // Websocket connection
        let ws 

        document.getElementById('connect').onclick = () => {
            if (ws) {
                ws.close();
            }
            ws = new WebSocket('ws://localhost:8080/connect');

            ws.onopen = function(event) {
                connectionState.textContent = 'Connection opened';
            };

            ws.onmessage = function(event) {
                while (agentsDiv.firstChild) {
                    agentsDiv.removeChild(agentsDiv.firstChild);
                }
            
                const data = JSON.parse(event.data);

                const table = document.createElement('table');
                const headerRow = document.createElement('tr');

                // We get all different keys from the agents
                let agtkeys = [];
                data.agents.forEach(agent => {
                    Object.keys(agent).forEach((key) => {
                        if (!agtkeys.includes(key)) {
                            agtkeys.push(key)
                        }
                    });
                });
                
                // Generalization for header insertion
                agtkeys.forEach((key) => {
                    const valueHeader = document.createElement('th');
                    // Capitalize first letter
                    valueHeader.textContent = key.charAt(0).toUpperCase() + key.slice(1);;
                    headerRow.appendChild(valueHeader);
                })
                table.appendChild(headerRow);

                data.agents.forEach(agent => {
                    const row = document.createElement('tr');
                    row.onclick = () => {
                        console.log('Selected agent:', agent.id);
                        selectedAgt = agent.id;
                    }
                    console.log('Selected agent:', selectedAgt);
                    if (selectedAgt === agent.id) {
                        row.classList.add('selected');
                    }
                    // Generalization of value insertion
                    agtkeys.forEach((key) => {
                        const valueCell = document.createElement('td');
                        if (typeof agent[key] === 'object') {
                            valueCell.textContent = JSON.stringify(agent[key]);
                        } else {
                            valueCell.textContent = agent[key] ?? 'N/A';
                        }
                        row.appendChild(valueCell);
                    });
                    
                    table.appendChild(row);
                });

                agentsDiv.appendChild(table);

                // Map rendering
                const mapCanvas = document.getElementById('map');
                const ctx = mapCanvas.getContext('2d');
                const cellSize = 25;
                const size = data.environment.mapDimension;
                mapCanvas.style.width = (cellSize * size) + "px";
                mapCanvas.style.height = (cellSize * size) + "px";
                mapCanvas.width = cellSize * size;
                mapCanvas.height = cellSize * size;
                clearCanvas(mapCanvas);

                data.agents.forEach(agent => {
                    drawAgent(ctx, agent, cellSize);
                });

                data.objects.forEach(object => {
                    drawObject(ctx, object, cellSize);
                });
            };

            ws.onerror = function(event) {
                errorsDiv.innerHTML += '<p>Error: ' + event.message + '</p>';
            };

            ws.onclose = function(event) {
                connectionState.textContent = 'Connection closed';
                ws.close(1, "bye")
            };

            ws.onopen = function(event) {
                connectionState.textContent = 'Connected'
            }



        document.getElementById('start-simulation').onclick = () => {
            ws.send('start');
        }

        document.getElementById('stop-simulation').onclick = () => {
            ws.send('stop');
        }

        document.getElementById('new-simulation').onclick = () => {
            ws.send('new');
        tr:hover {
            background-color: lightblue;
        }

        tr.selected {
            background-color: lightgreen;
        }
    </script>
</body>
</html>