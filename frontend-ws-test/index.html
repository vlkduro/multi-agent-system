<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI30 WebSocket</title>
    <script src="./utils/pixi.min.js"></script>
    <link rel="stylesheet" href="css/main_style.css">
</head>
<body>
    <h1>AI30 WebSocket Debug App</h1>
    <div style="display:flex; gap:10px">
        <button id="start-simulation">Start simulation</button>
        <button id="stop-simulation">Stop simulation</button>
        <button id="new-simulation">New simulation</button>
    </div>
    <h2 id="connection-state">Connection closed</h2>
    <div>
        <canvas id="map"></canvas>
    </div>
    <div>
        <table id="hives">
        </table>
    </div> 
    <div id="agents"></div>
    <div id="errors"></div>
    <script>
        const URL = 'http://localhost:8080/';
        const ws = new WebSocket('ws://localhost:8080/');
        const agentsDiv = document.getElementById('agents');
        const hivesDiv = document.getElementById('hives');
        const connectionState = document.getElementById('connection-state');
        const errorsDiv = document.getElementById('errors');

        let selectedAgt = undefined;

        function clearCanvas(canvas) {
            const context = canvas.getContext('2d');
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = 'lightgrey';
            context.fillRect(0, 0, canvas.width, canvas.height);
        }

        function findRightFont(ctx, startSize, text, maxHeight, maxWidth) {
            let font = startSize;
            let dimensions = ctx.measureText(text);
            while (dimensions.height > maxHeight || dimensions.width > maxWidth) {
                font--;
                ctx.font = font + 'px Arial';
                dimensions = ctx.measureText(text);
            }
            return font;
        }

        // https://stackoverflow.com/questions/808826/draw-arrow-on-canvas-tag
        function canvas_arrow(ctx, fromx, fromy, tox, toy) {
            ctx.beginPath();
            var headlen = 10; // length of head in pixels
            var dx = tox - fromx;
            var dy = toy - fromy;
            var angle = Math.atan2(dy, dx);
            ctx.moveTo(fromx, fromy);
            ctx.lineTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        function getTriangleCoordinates(startPt, height, oppositeBaseSize, orientation) {
            const topCorner = { ...startPt };
            let leftCorner, rightCorner;
            switch (orientation) {
                case 'N':
                    rightCorner = { x: startPt.x - oppositeBaseSize / 2, y: startPt.y - height };
                    leftCorner = { x: startPt.x + oppositeBaseSize / 2, y: startPt.y - height };
                    break;
                case 'S':
                    leftCorner = { x: startPt.x - oppositeBaseSize / 2, y: startPt.y + height };
                    rightCorner = { x: startPt.x + oppositeBaseSize / 2, y: startPt.y + height };
                    break;
                case 'E':
                    rightCorner = { x: startPt.x + height, y: startPt.y - oppositeBaseSize / 2 };
                    leftCorner = { x: startPt.x + height, y: startPt.y + oppositeBaseSize / 2 };
                    break;
                case 'W':
                    leftCorner = { x: startPt.x - height, y: startPt.y - oppositeBaseSize / 2 };
                    rightCorner = { x: startPt.x - height, y: startPt.y + oppositeBaseSize / 2 };
                    break;
            }
            return { topCorner, leftCorner, rightCorner };
        }

        function pointIsInTriangle(x, y, topCorner, leftCorner, rightCorner) {
            function calculateArea(x1, y1, x2, y2, x3, y3) {
                return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0);
            }

            const area = calculateArea(topCorner.x, topCorner.y, leftCorner.x, leftCorner.y, rightCorner.x, rightCorner.y);
            const area1 = calculateArea(x, y, leftCorner.x, leftCorner.y, rightCorner.x, rightCorner.y);
            const area2 = calculateArea(topCorner.x, topCorner.y, x, y, rightCorner.x, rightCorner.y);
            const area3 = calculateArea(topCorner.x, topCorner.y, leftCorner.x, leftCorner.y, x, y);

            return area === area1 + area2 + area3;
        }

        function drawAgentVision(ctx, agent, cellSize) {
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = 'rgba(0, 255, 0, 1)';
            ctx.strokeStyle = 'rgba(0, 255, 0, 1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            agent.seenElems.forEach(seen => {
                ctx.fillRect(seen.position.x * cellSize, seen.position.y * cellSize, cellSize, cellSize)
            })
            ctx.globalAlpha = 1;
            ctx.closePath();
		}

        function drawAgent(ctx, agent, cellSize) {
            text = agent.id.replace('ExAgent ', 'ExA');
            let agtX = agent.position.x * cellSize;
            let agtY = agent.position.y * cellSize;
            if (agent.id === selectedAgt) {
                ctx.fillStyle = 'lightgreen';
                drawAgentVision(ctx, agent, cellSize);
            }
            else {
                ctx.fillStyle = 'yellow';
            }
            // drawing yellow square
            ctx.fillRect(agtX, agtY, cellSize, cellSize);
            // drawing movement
            ctx.strokeStyle = 'red';
            if (agent.orientation === "N") {
                canvas_arrow(ctx, agtX + cellSize / 2, agtY + cellSize, agtX + cellSize / 2, agtY);
            } else if (agent.orientation === "E") {
                canvas_arrow(ctx, agtX, agtY + cellSize / 2, agtX + cellSize, agtY + cellSize/2);
            } else if (agent.orientation === "S") {
                canvas_arrow(ctx, agtX + cellSize / 2, agtY, agtX + cellSize / 2, agtY + cellSize);
            } else if (agent.orientation === "W") {
                canvas_arrow(ctx, agtX + cellSize, agtY + cellSize / 2, agtX, agtY + cellSize/2);
            } else if (agent.orientation == "NE") {
                canvas_arrow(ctx, agtX, agtY + cellSize, agtX + cellSize, agtY);
            } else if (agent.orientation == "NW") {
                canvas_arrow(ctx, agtX + cellSize, agtY + cellSize, agtX, agtY);
            } else if (agent.orientation == "SE") {
                canvas_arrow(ctx, agtX, agtY, agtX + cellSize, agtY + cellSize);
            } else if (agent.orientation == "SW") {
                canvas_arrow(ctx, agtX + cellSize, agtY, agtX, agtY + cellSize);
            } 
            // drawing text
            font = findRightFont(ctx, 10, text, cellSize, cellSize);
            ctx.fillStyle = 'black';
            ctx.font = font + 'px Arial';
            ctx.fillText(text, agtX, agtY + cellSize / 2);
        }

        function drawObject(ctx, object, cellSize) {
            let text = object.id;
            if (object.id.includes('Flower')) {
                ctx.fillStyle = 'red';
                text = object.id.replace('Flower ', 'F');
            } 
            else if (object.id.includes('Hive')) {
                ctx.fillStyle = 'orange';
                text = object.id.replace('Hive ', 'H');
            }
            else {
                ctx.fillStyle = 'green';
            }
            objX = object.position.x * cellSize;
            objY = object.position.y * cellSize;
            ctx.fillRect(objX, objY, cellSize, cellSize);
            font = findRightFont(ctx, 10, text, cellSize, cellSize);
            ctx.fillStyle = 'black';
            ctx.font = font + 'px Arial';
            ctx.fillText(text, objX, objY + cellSize / 2);
        }

        //Function trigered when data are reiceve from websocket
        ws.onmessage = function(event) {
            while (agentsDiv.firstChild) {
                agentsDiv.removeChild(agentsDiv.firstChild);
            }
            while (hivesDiv.firstChild) {
                hivesDiv.removeChild(hivesDiv.firstChild);
            }
        
            const data = JSON.parse(event.data);

            const table = document.createElement('table');
            const headerRow = document.createElement('tr');

            // We get all different keys from the agents
            let agtkeys = [];
            data.agents.forEach(agent => {
                Object.keys(agent).forEach((key) => {
                    if (!agtkeys.includes(key)) {
                        agtkeys.push(key)
                    }
                });
            });
            
            // Generalization for header insertion
            agtkeys.forEach((key) => {
                const valueHeader = document.createElement('th');
                // Capitalize first letter
                valueHeader.textContent = key.charAt(0).toUpperCase() + key.slice(1);;
                headerRow.appendChild(valueHeader);
            })
            table.appendChild(headerRow);

            data.agents.forEach(agent => {
                const row = document.createElement('tr');
                // Generalization of value insertion
                agtkeys.forEach((key) => {
                    const valueCell = document.createElement('td');
                    if (typeof agent[key] === 'object') {
                        valueCell.textContent = JSON.stringify(agent[key]);
                    } else {
                        valueCell.textContent = agent[key] ?? 'N/A';
                    }
                    row.appendChild(valueCell);
                });
                
                table.appendChild(row);
            });

            agentsDiv.appendChild(table);

            // Map rendering
            const mapCanvas = document.getElementById('map');
            const ctx = mapCanvas.getContext('2d');
            const cellSize = 25;
            const size = data.environment.mapDimension;
            mapCanvas.style.width = (cellSize * size) + "px";
            mapCanvas.style.height = (cellSize * size) + "px";
            mapCanvas.width = cellSize * size;
            mapCanvas.height = cellSize * size;
            clearCanvas(mapCanvas);

            data.agents.forEach(agent => {
                drawAgent(ctx, agent, cellSize);
            });

            data.objects.forEach(object => {
                drawObject(ctx, object, cellSize);
                if (object.id.includes('Hive')) {
                    if (!hivesDiv.firstChild) {
                        const row = document.createElement('tr');
                        Object.keys(object).forEach((key) => {
                            const valueCell = document.createElement('th');
                            valueCell.textContent = key;
                            row.appendChild(valueCell);
                        });
                        hivesDiv.appendChild(row);
                    }
                    const row = document.createElement('tr');
                    // Generalization of value insertion
                    Object.keys(object).forEach((key) => {
                        const valueCell = document.createElement('td');
                        if (typeof object[key] === 'object') {
                            valueCell.textContent = JSON.stringify(object[key]);
                        } else {
                            valueCell.textContent = object[key] ?? 'N/A';
                        }
                        row.appendChild(valueCell);
                    });
                    
                    hivesDiv.appendChild(row);
                }
            });
        }

        ws.onerror = function(event) {
            errorsDiv.innerHTML += '<p>Error: ' + event.message + '</p>';
        };

        ws.onclose = function(event) {
            connectionState.textContent = 'Connection closed';
            ws.close(1, "bye")
        };

        ws.onopen = function(event) {
            connectionState.textContent = 'Connected'
        }
        


        document.getElementById('start-simulation').onclick = () => {
            ws.send('start');
        }

        document.getElementById('stop-simulation').onclick = () => {
            ws.send('stop');
        }

        document.getElementById('new-simulation').onclick = () => {
            ws.send('new');
        }
    </script> 
</body>
</html>